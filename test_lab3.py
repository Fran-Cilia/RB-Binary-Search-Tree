import lab3
import unittest


class T0_tree__insert(unittest.TestCase):
    def test_balanced_binary_search_tree(self):
        print("\n")
        print("tree_insert_with_individual_check")
        t = lab3.Tree()
        t.insert(4)
        t.insert(2)
        t.insert(6)
        t.insert(1)
        t.insert(3)
        t.insert(5)
        t.insert(7)
        #The following check is without using tree as an iterator (which uses inorder traversal)
        #So this function also does not check the implementation of the traversal function
        self.assertEqual(t.root.data, 4)
        self.assertEqual(t.root.left.data, 2)
        self.assertEqual(t.root.left.left.data, 1)
        self.assertEqual(t.root.left.right.data, 3)
        self.assertEqual(t.root.right.data, 6)
        self.assertEqual(t.root.right.left.data, 5)
        self.assertEqual(t.root.right.right.data, 7)
        print("\n")

class T1_skewed_tree__insert(unittest.TestCase):
    def test_skewed_binary_search_tree(self):
        print("\n")
        print("tree_insert_with_individual_check")
        t = lab3.Tree()
        t.insert(10)
        t.insert(9)
        t.insert(8)
        t.insert(7)
        t.insert(6)
        t.insert(5)
        t.insert(4)
        t.insert(3)
        t.insert(2)
        t.insert(1)
        t.insert(0)
        #The following check is without using tree as an iterator (which uses inorder traversal)
        #So this function also does not check the implementation of the traversal function
        self.assertEqual(t.root.data, 7)
        self.assertEqual(t.root.left.data, 5)
        self.assertEqual(t.root.right.data, 9)
        self.assertEqual(t.root.left.left.data, 3)
        self.assertEqual(t.root.left.right.data, 6)
        self.assertEqual(t.root.right.left.data, 8)
        self.assertEqual(t.root.right.right.data, 10)
        self.assertEqual(t.root.left.left.left.data, 1)
        self.assertEqual(t.root.left.left.right.data, 4)
        self.assertEqual(t.root.left.left.left.left.data, 0)
        self.assertEqual(t.root.left.left.left.right.data, 2)
        print("\n")

class T2_skewed_tree_colors__insert(unittest.TestCase):
    def test_skewed_colors_binary_search_tree(self):
        print("\n")
        print("tree_insert_with_individual_check")
        t = lab3.Tree()
        t.insert(10)
        t.insert(9)
        t.insert(8)
        t.insert(7)
        t.insert(6)
        t.insert(5)
        t.insert(4)
        t.insert(3)
        t.insert(2)
        t.insert(1)
        t.insert(0)
        #The following check is without using tree as an iterator (which uses inorder traversal)
        #So this function also does not check the implementation of the traversal function
        self.assertEqual(t.root.color, 0)
        self.assertEqual(t.root.left.color, 0)
        self.assertEqual(t.root.right.color, 0)
        self.assertEqual(t.root.left.left.color, 1)
        self.assertEqual(t.root.left.right.color, 0)
        self.assertEqual(t.root.right.left.color, 0)
        self.assertEqual(t.root.right.right.color, 0)
        self.assertEqual(t.root.left.left.left.color, 0)
        self.assertEqual(t.root.left.left.right.color, 0)
        self.assertEqual(t.root.left.left.left.left.color, 1)
        self.assertEqual(t.root.left.left.left.right.color, 1)
        print("\n")

class T3_skewed_tree__insert(unittest.TestCase):
    def test_skewed_binary_search_tree(self):
        print("\n")
        print("tree_insert_with_individual_check")
        t = lab3.Tree()
        t.insert(10)
        t.insert(11)
        t.insert(12)
        t.insert(13)
        t.insert(14)
        t.insert(15)
        t.insert(16)
        t.insert(17)
        t.insert(18)
        t.insert(19)
        t.insert(20)
        #The following check is without using tree as an iterator (which uses inorder traversal)
        #So this function also does not check the implementation of the traversal function
        self.assertEqual(t.root.data, 13)
        self.assertEqual(t.root.left.data, 11)
        self.assertEqual(t.root.right.data, 15)
        self.assertEqual(t.root.left.left.data, 10)
        self.assertEqual(t.root.left.right.data, 12)
        self.assertEqual(t.root.right.left.data, 14)
        self.assertEqual(t.root.right.right.data, 17)
        self.assertEqual(t.root.right.right.left.data, 16)
        self.assertEqual(t.root.right.right.right.data, 19)
        self.assertEqual(t.root.right.right.right.left.data, 18)
        self.assertEqual(t.root.right.right.right.right.data, 20)
        print("\n")

class T3_skewed_tree__insert(unittest.TestCase):
    def test_skewed_colors_binary_search_tree(self):
        print("\n")
        print("tree_insert_with_individual_check")
        t = lab3.Tree()
        t.insert(10)
        t.insert(11)
        t.insert(12)
        t.insert(13)
        t.insert(14)
        t.insert(15)
        t.insert(16)
        t.insert(17)
        t.insert(18)
        t.insert(19)
        t.insert(20)
        #The following check is without using tree as an iterator (which uses inorder traversal)
        #So this function also does not check the implementation of the traversal function
        self.assertEqual(t.root.color, 0)
        self.assertEqual(t.root.left.color, 0)
        self.assertEqual(t.root.right.color, 0)
        self.assertEqual(t.root.left.left.color, 0)
        self.assertEqual(t.root.left.right.color, 0)
        self.assertEqual(t.root.right.left.color, 0)
        self.assertEqual(t.root.right.right.color, 1)
        self.assertEqual(t.root.right.right.left.color, 0)
        self.assertEqual(t.root.right.right.right.color, 0)
        self.assertEqual(t.root.right.right.right.left.color, 1)
        self.assertEqual(t.root.right.right.right.right.color, 1)
        print("\n")

class T4_single__insert(unittest.TestCase):
    def test_single_insertion_binary_search_tree(self):
        print("\n")
        print("tree_insert_with_single_insertion")
        t = lab3.Tree()
        t.insert(100)
        self.assertEqual(t.root.data, 100)


if __name__ == '__main__' :
    unittest.main()
